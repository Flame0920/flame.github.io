<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flame&#39;s Security Home</title>
  
  
  <link href="https://flame0920.github.io/flame.github.io/atom.xml" rel="self"/>
  
  <link href="https://flame0920.github.io/flame.github.io/"/>
  <updated>2022-05-16T09:04:34.028Z</updated>
  <id>https://flame0920.github.io/flame.github.io/</id>
  
  <author>
    <name>BurnFlame</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>InfinityHook</title>
    <link href="https://flame0920.github.io/flame.github.io/2022/01/15/InfinityHook/"/>
    <id>https://flame0920.github.io/flame.github.io/2022/01/15/InfinityHook/</id>
    <published>2022-01-15T11:59:06.000Z</published>
    <updated>2022-05-16T09:04:34.028Z</updated>
    
    <content type="html"><![CDATA[<p> 分析InfinityHook</p><span id="more"></span><h3 id="InfinityHook剖析"><a href="#InfinityHook剖析" class="headerlink" title="InfinityHook剖析"></a>InfinityHook剖析</h3><p>​    整体原理请看<a href="https://bbs.pediy.com/thread-253450.htm">https://bbs.pediy.com/thread-253450.htm</a> 剖析 InfinityHook 原理 掀起一场更激烈的攻与防恶战 </p><p>​    本文着重讲解这篇文章中令人疑惑的几个重点 :</p><ul><li>ClientContext 值分别为1、2、3时的3个不同的函数是在哪里被赋值和调用的</li><li>EnableFlags 的值是如何影响ETW流程的</li><li>EnableFlags  == EVENT_TRACE_FLAG_SYSTEMCALL时， 替换函数是如何定位到syscall的函数地址以及调用号</li><li>扩展EnableFlags == 其他值时，如何hook</li></ul><p><strong>关键函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXTERN_C</span></span><br><span class="line"><span class="function">NTSYSCALLAPI </span></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function">NTAPI</span></span><br><span class="line"><span class="function"><span class="title">ZwTraceControl</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG FunctionCode,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_reads_bytes_opt_(InBufferLen) PVOID InBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG InBufferLen,</span></span></span><br><span class="line"><span class="params"><span class="function">     _Out_writes_bytes_opt_(OutBufferLen) PVOID OutBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG OutBufferLen,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PULONG ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="1、ClientContext"><a href="#1、ClientContext" class="headerlink" title="1、ClientContext"></a>1、ClientContext</h3><p>​    当FunctionCode == EtwpStartTrace时，调用<strong>NtTraceControl</strong>，会走到<strong>EtwpStartTrace</strong>函数，其中调用了<strong>EtwpStartLogger</strong>函数，参数与<strong>EtwpStartTrace</strong>一致。</p><p>​    追踪<strong>ClientContext</strong>字段：</p><p><img src="/flame.github.io/flame.github.io/2022/01/15/InfinityHook/image-20220116172443129.png"></p><p>​    <strong>EtwpInitLoggerContext</strong> 申请了一个**_WMI_LOGGER_CONTEXT**结构的指针LoggerContext，</p><p>并在接下来的过程中使得<strong>LoggerContext</strong>-&gt;ClockType = <strong>Properties</strong>-&gt;ClientContext</p><p>(Properties 指针是ZwTraceControl传入的指针，详情请看文章开头的链接)</p><p>​    之后调用关键函数 ： <strong>EtwpInitializeTimeStamp</strong></p><p>​    </p><p>​    在这个函数内：</p><p><img src="/flame.github.io/flame.github.io/2022/01/15/InfinityHook/image-20220116174711686.png"></p><p>​    通过ClockType来获取相应的函数  : </p><ul><li><p>当ClockType = 1时， LoggerContext-&gt;GetCpuClock = <strong>PpmQueryTime</strong></p></li><li><p>当ClockType = 2时， LoggerContext-&gt;GetCpuClock = <strong>EtwpGetSystemTime</strong></p></li><li><p>当ClockType = 3时， LoggerContext-&gt;GetCpuClock = <strong>EtwpGetCycleCount</strong></p></li><li><p>当ClockType = 4时，如果EtwpGetHostPerfCounter能执行成功，则为EtwpGetHostPerfCounter，如果执行失败，则ClockType = 1；</p><p>至此，函数赋值点以及规则弄清楚了，接下来就是搞清楚哪里调用的<strong>GetCpuClock</strong> 函数。</p><p>拿syscall监控举例 : </p><p><img src="/flame.github.io/flame.github.io/2022/01/15/InfinityHook/image-20220117164224033.png" alt="image-20220117164224033"></p></li></ul><p>在调用NT函数前，先调用了<strong>PerfInfoLogSysCallEntry</strong>函数：</p><p><img src="/flame.github.io/flame.github.io/2022/01/15/InfinityHook/image-20220117175650031.png" alt="image-20220117175650031"></p><p>PerfInfoLogSysCallEntry函数中红箭头指向位置为MagicCode，可以用来标定栈的位置，以便寻找调用函数地址和调用号，具体分析在第三节。</p><p>继续跟踪<strong>EtwTraceSiloKernelEvent</strong>，发现调用了<strong>EtwpLogKernelEvent</strong>函数：</p><p><img src="/flame.github.io/flame.github.io/2022/01/15/InfinityHook/image-20220117182009670.png" alt="image-20220117182009670"></p><p>跟踪<strong>EtwpLogKernelEvent</strong>函数，调用了<strong>EtwpReserveTraceBuffer</strong>函数：</p><p><img src="/flame.github.io/flame.github.io/2022/01/15/InfinityHook/image-20220117182051726.png" alt="image-20220117182051726"></p><p>在<strong>EtwpReserveTraceBuffer</strong>函数中发现：</p><p><img src="/flame.github.io/flame.github.io/2022/01/15/InfinityHook/image-20220117182204758.png" alt="image-20220117182204758"></p><p>​    此处函数调用的偏移点0x28与之前分析的赋值偏移点<strong>GetCpuClock</strong>(0x28)一致，所以此处就是<strong>GetCpuClock</strong>的调用点（这里分析结论下得比较武断，其实需要利用windbg下断点来看看是否真的一致，但是我懒了 - -）。</p><p>​    此时分析的关键点变成<strong>rdi</strong>从何处来，根据IDA可知，<strong>EtwpReserveTraceBuffer</strong>中rdi = rcx，而rcx来自<strong>EtwpLogKernelEvent</strong>中mov rcx, r14。所以需要找出<strong>r14</strong>从何处来：</p><p><img src="/flame.github.io/flame.github.io/2022/01/15/InfinityHook/image-20220117182703739.png" alt="image-20220117182703739"></p><p>​    根据上图可知，r14 = [rcx + rax] = [[r12 + 0x1C8] + r15<em>8], 而在<strong>EtwpLogKernelEvent</strong>中*<em>r12 = rdx</em></em> ， rdx来自<strong>EtwTraceSiloKernelEvent</strong>函数中的：</p><p><img src="/flame.github.io/flame.github.io/2022/01/15/InfinityHook/image-20220117182852327.png" alt="image-20220117182852327"></p><p>​    r15 根据windbg逆向可得 r15 = 2（实际上R15来自<strong>EtwpLogKernelEvent</strong> 中r8，而r8的赋值比较复杂，这里简化起见直接给结论），所以最后结果就是</p><p>LoggerContext = [[[<strong>EtwpHostSiloState</strong>] + 0x1C8] + 0x10]。</p><p>​    根据上述结论可知，如果要替换<strong>GetCpuClock</strong>函数，则需要定位到<strong>EtwpHostSiloState</strong>，此处有个特殊的地方，根据IDA交叉引用可以看到：</p><p><img src="/flame.github.io/flame.github.io/2022/01/15/InfinityHook/image-20220117184204261.png" alt="image-20220117184204261"></p><p>​    在一个函数中，EtwpHostSiloState被赋值：</p><p><img src="/flame.github.io/flame.github.io/2022/01/15/InfinityHook/image-20220117184938866.png"></p><p>​    这里有两个全局变量被赋予值，<strong>qword_140429E08</strong> = [rdi + 0x1C8] , <strong>qword_140429E10</strong> = rdi通过IDA查看该值：</p><p><img src="/flame.github.io/flame.github.io/2022/01/15/InfinityHook/image-20220117184302975.png" alt="image-20220117184302975"></p><p>​    发现全局变量 <strong>qword_140429E08</strong> - 0x10的位置有一个<strong>EtwpDebuggerData</strong>，这个可以通过特征码定位，简化寻找<strong>EtwpHostSiloState</strong>的流程（因为EtwpDebuggerData绝大部分系统都有，而EtwpHostSiloState在不同的系统名称不同）。</p><p>​    所以，LoggerContext =[[[<strong>EtwpDebuggerData + 0x18</strong>] + 0x1C8] + 0x10] , 或者 LoggerContext =[[<strong>EtwpDebuggerData + 0x10</strong>] + 0x10]</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 分析InfinityHook&lt;/p&gt;</summary>
    
    
    
    <category term="C/C++" scheme="https://flame0920.github.io/flame.github.io/categories/C-C/"/>
    
    <category term="Driver" scheme="https://flame0920.github.io/flame.github.io/categories/C-C/Driver/"/>
    
    
    <category term="Driver" scheme="https://flame0920.github.io/flame.github.io/tags/Driver/"/>
    
    <category term="C/C++" scheme="https://flame0920.github.io/flame.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>WRK驱动加载流程分析(下)</title>
    <link href="https://flame0920.github.io/flame.github.io/2021/11/17/WRK%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-%E4%B8%8B/"/>
    <id>https://flame0920.github.io/flame.github.io/2021/11/17/WRK%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-%E4%B8%8B/</id>
    <published>2021-11-17T13:15:21.000Z</published>
    <updated>2021-11-17T13:15:21.782Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>WRK驱动加载流程分析(中)</title>
    <link href="https://flame0920.github.io/flame.github.io/2021/11/17/WRK%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-%E4%B8%AD/"/>
    <id>https://flame0920.github.io/flame.github.io/2021/11/17/WRK%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-%E4%B8%AD/</id>
    <published>2021-11-17T13:15:15.000Z</published>
    <updated>2022-05-16T08:30:27.047Z</updated>
    
    <content type="html"><![CDATA[<p> 分析驱动加载中的关键函数(中篇) — 分析 MmLoadSystemImage</p><span id="more"></span><h3 id="MmLoadSystemImage"><a href="#MmLoadSystemImage" class="headerlink" title="MmLoadSystemImage"></a>MmLoadSystemImage</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MmLoadSystemImage</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PUNICODE_STRING ImageFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PUNICODE_STRING NamePrefix OPTIONAL,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PUNICODE_STRING LoadedBaseName OPTIONAL,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG LoadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PVOID *ImageHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PVOID *ImageBaseAddress</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><ul><li><strong>ImageFileName</strong>： 需要加载的Image的完整路径，包括image名字</li><li><strong>NamePrefix</strong>： image名字前缀，通过使用不同的前缀，可以多次加载相同的image</li><li><strong>LoadedBaseName</strong>： 指定加载image的名字</li><li><strong>LoadFlags</strong>：<ul><li>MM_LOAD_IMAGE_IN_SESSION (0x1)： 是否在会话空间中加载image</li><li>MM_LOAD_IMAGE_AND_LOCKDOWN (0x2):  如果为TURE, image的Page段应该为non-pageable</li></ul></li><li><strong>ImageHandle</strong>：返回加载的image的section pointer</li><li><strong>ImageBaseAddress</strong>： 保存加载的image基址</li></ul><h4 id="函数体分析"><a href="#函数体分析" class="headerlink" title="函数体分析"></a>函数体分析</h4><ol><li><p>判断是否需要加载到进程会话空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (LoadFlags &amp; MM_LOAD_IMAGE_IN_SESSION) &#123;</span><br><span class="line">    <span class="comment">// 需要加载到会话空间</span></span><br><span class="line">    <span class="built_in">ASSERT</span> (NamePrefix == <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">ASSERT</span> (LoadedBaseName == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">PsGetCurrentProcess</span>()-&gt;Flags &amp; PS_PROCESS_FLAGS_IN_SESSION) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前进程没有会话空间 （猜测PS_PROCESS_FLAGS_IN_SESSION含义）</span></span><br><span class="line">        <span class="keyword">return</span> STATUS_NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化局部变量</p></li><li><p>通过<strong>ImageFileName</strong>获取image文件名</p></li><li><p>如果<strong>NamePrefix</strong>参数存在，则添加BaseName  = <strong>NamePrefix</strong> + BaseName </p></li><li><p>如果<strong>LoadedBaseName</strong>参数存在，则BaseName = <strong>LoadedBaseName</strong></p></li><li><p>阻止当前上下文环境APC</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    LoadLockOwned = TRUE;</span><br><span class="line"></span><br><span class="line">    CurrentThread = <span class="built_in">KeGetCurrentThread</span> ();</span><br><span class="line">    <span class="built_in">KeEnterCriticalRegionThread</span> (CurrentThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// KeWaitForSingleObject 这个有待分析</span></span><br><span class="line">    <span class="built_in">KeWaitForSingleObject</span> (&amp;MmSystemLoadLock,</span><br><span class="line">                           WrVirtualMemory,</span><br><span class="line">                           KernelMode,</span><br><span class="line">                           FALSE,</span><br><span class="line">                           (PLARGE_INTEGER)<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li><li><p>查找<strong>image</strong>是否已经加载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NextEntry = PsLoadedModuleList.Flink;</span><br><span class="line"><span class="keyword">while</span> (NextEntry != &amp;PsLoadedModuleList) &#123;</span><br><span class="line"></span><br><span class="line">    DataTableEntry = <span class="built_in">CONTAINING_RECORD</span> (NextEntry,</span><br><span class="line">                                        KLDR_DATA_TABLE_ENTRY,</span><br><span class="line">                                        InLoadOrderLinks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RtlEqualUnicodeString</span> (&amp;PrefixedImageName,</span><br><span class="line">                               &amp;DataTableEntry-&gt;FullDllName,</span><br><span class="line">                               TRUE)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 如果发现相同名字的模块，则break跳出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NextEntry = NextEntry-&gt;Flink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果image模块已经加载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (NextEntry != &amp;PsLoadedModuleList)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((LoadFlags &amp; MM_LOAD_IMAGE_IN_SESSION) == <span class="number">0</span>) &#123; <span class="comment">// 不用加载到会话空间中</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">MI_IS_SESSION_ADDRESS</span> (DataTableEntry-&gt;DllBase) == TRUE) &#123;</span><br><span class="line">           <span class="comment">// 发现加载的模块在会话空间地址段内</span></span><br><span class="line">           Status = STATUS_CONFLICTING_ADDRESSES;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 加载的模块不在会话空间地址段内，保存ImageHandle和ImageBaseAddress，并返回</span></span><br><span class="line">           *ImageHandle = DataTableEntry; </span><br><span class="line">           *ImageBaseAddress = DataTableEntry-&gt;DllBase;</span><br><span class="line">           Status = STATUS_IMAGE_ALREADY_LOADED;</span><br><span class="line">       &#125;</span><br><span class="line">            <span class="keyword">goto</span> return2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 走到这里说明 LoadFlags &amp; MM_LOAD_IMAGE_IN_SESSION ！= 0， 驱动是要加载到会话空间中的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">MI_IS_SESSION_ADDRESS</span> (DataTableEntry-&gt;DllBase) == FALSE) &#123;</span><br><span class="line">            <span class="comment">// 如果加载的模块地址不在会话空间地址段内，则返回STATUS_CONFLICTING_ADDRESSES</span></span><br><span class="line">            Status = STATUS_CONFLICTING_ADDRESSES;</span><br><span class="line">            <span class="keyword">goto</span> return2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ........</span><br><span class="line">        Status = <span class="built_in">MiSessionInsertImage</span> (DataTableEntry-&gt;DllBase);   <span class="comment">// 插入到会话空间image list中</span></span><br><span class="line"></span><br><span class="line">    ........</span><br><span class="line">        <span class="comment">// Status == STATUS_SUCCESS走下面</span></span><br><span class="line">        <span class="comment">// （英文目标有待分析）</span></span><br><span class="line">        <span class="comment">// This driver is already loaded in the system, but not in</span></span><br><span class="line">        <span class="comment">// this particular session - share it now.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        FoundDataTableEntry = DataTableEntry;</span><br><span class="line"></span><br><span class="line">        DataTableEntry-&gt;LoadCount += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ASSERT</span> (DataTableEntry-&gt;SectionPointer != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        SectionPointer = DataTableEntry-&gt;SectionPointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果image模块没有加载，且SectionPointer == nullptr </p><ul><li><strong>ZwOpenFile</strong>打开文件</li><li><strong>MmCheckSystemImage</strong>检查文件是否符合要求</li><li>如果要加载到会话空间，<strong>SectionAccess</strong> = <strong>SECTION_MAP_READ</strong> | <strong>SECTION_MAP_EXECUTE</strong>，否则<strong>SectionAccess</strong>  = <strong>SECTION_ALL_ACCESS</strong>；</li><li><strong>ZwCreateSection</strong>创建节对象</li><li><strong>ObReferenceObjectByHandle</strong>获取<strong>SectionPointer</strong></li></ul></li></ul></li><li><p>通过<strong>MiLoadImageSection</strong>函数加载Image模块到内核地址空间中</p></li><li><p>如果驱动是第一次加载:</p><ul><li><pre><code class="c++">        if (((LoadFlags &amp; MM_LOAD_IMAGE_IN_SESSION) == 0) ||            (*ImageBaseAddress != SectionPointer-&gt;Segment-&gt;BasedAddress)) &#123;            // 不是加载到会话空间，且预想加载地址和实际加载地址不一致            __try &#123;                Status = LdrRelocateImage (*ImageBaseAddress,                                           &quot;SYSLDR&quot;,                                           STATUS_SUCCESS,                                           STATUS_CONFLICTING_ADDRESSES,                                           STATUS_INVALID_IMAGE_FORMAT);            &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;                Status = GetExceptionCode ();                KdPrint((&quot;MM:sysload - LdrRelocateImage failed status %lx\n&quot;,                          Status));            &#125;            if (!NT_SUCCESS(Status)) &#123;                //                // Unload the system image and dereference the section.                //                goto return1;            &#125;              &#125;     </code></pre></li><li><p>如果是加载到会话空间中 ： 略</p></li><li><p>填充DataTableEntry（PKLDR_DATA_TABLE_ENTRY）</p></li><li><p><strong>MiCaptureImageExceptionValues</strong>(DataTableEntry) : </p><p>向DataTableEntry-&gt;ExceptionTable写入信息</p></li><li><p><strong>MiProcessLoaderEntry</strong> (DataTableEntry, TRUE) ： 将DataTableEntry 插入到 PsLoadedModuleList中 （<strong>重要</strong>）</p></li><li><p>MiResolveImageReferences()  </p></li><li><p>Call Image 回调</p></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt; 分析驱动加载中的关键函数(中篇) — 分析 MmLoadSystemImage&lt;/p&gt;</summary>
    
    
    
    <category term="C/C++" scheme="https://flame0920.github.io/flame.github.io/categories/C-C/"/>
    
    <category term="Driver" scheme="https://flame0920.github.io/flame.github.io/categories/C-C/Driver/"/>
    
    <category term="WRK" scheme="https://flame0920.github.io/flame.github.io/categories/C-C/Driver/WRK/"/>
    
    
    <category term="Driver" scheme="https://flame0920.github.io/flame.github.io/tags/Driver/"/>
    
    <category term="C/C++" scheme="https://flame0920.github.io/flame.github.io/tags/C-C/"/>
    
    <category term="WRK" scheme="https://flame0920.github.io/flame.github.io/tags/WRK/"/>
    
  </entry>
  
  <entry>
    <title>WRK驱动加载流程分析(上)</title>
    <link href="https://flame0920.github.io/flame.github.io/2021/11/16/WRK%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-%E4%B8%8A/"/>
    <id>https://flame0920.github.io/flame.github.io/2021/11/16/WRK%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-%E4%B8%8A/</id>
    <published>2021-11-16T10:45:30.000Z</published>
    <updated>2022-05-16T08:39:40.582Z</updated>
    
    <content type="html"><![CDATA[<p> 分析驱动加载中的关键函数(上篇)</p><span id="more"></span><h3 id="驱动加载中的关键函数"><a href="#驱动加载中的关键函数" class="headerlink" title="驱动加载中的关键函数"></a>驱动加载中的关键函数</h3><ul><li>NtLoadDriver<ul><li>IopLoadUnloadDriver<ul><li>IopLoadDriver<ul><li>MmLoadSystemImage</li><li>IopPrepareDriverLoading</li></ul></li><li>IopCallDriverReinitializationRoutines</li></ul></li></ul></li></ul><h3 id="关键函数分析"><a href="#关键函数分析" class="headerlink" title="关键函数分析"></a>关键函数分析</h3><h4 id="NtLoadDriver"><a href="#NtLoadDriver" class="headerlink" title="NtLoadDriver"></a>NtLoadDriver</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">NtLoadDriver</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PUNICODE_STRING DriverServiceName</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>1、判断是否是用户模式调用</p><p>2、如果是用户模式调用，则检查DriverServiceName</p><p>3、初始化LOAD_PACKET</p><p>4、判断是否是系统线程，如果是系统线程则直接调用IopLoadUnloadDriver</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">PsGetCurrentProcessByThread</span>(CurrentThread) == PsInitialSystemProcess) &#123;</span><br><span class="line">    <span class="built_in">IopLoadUnloadDriver</span>(&amp;loadPacket);    <span class="comment">// 系统线程，直接调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、如果不是系统线程，则是指工作环境，并等待</p><p>6、返回status</p><h4 id="IopLoadUnloadDriver"><a href="#IopLoadUnloadDriver" class="headerlink" title="IopLoadUnloadDriver"></a>IopLoadUnloadDriver</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">IopLoadUnloadDriver</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PVOID Parameter</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>1、如果存在DriverObject 则调用DriverUnload</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (loadPacket-&gt;DriverObject) &#123;</span><br><span class="line"></span><br><span class="line">    loadPacket-&gt;DriverObject-&gt;<span class="built_in">DriverUnload</span>( loadPacket-&gt;DriverObject );</span><br><span class="line">    status = STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、loadPacket-&gt;DriverObject == nullptr, 则说明是<strong>加载驱动</strong></p><p>3、<strong>IopOpenRegistryKey</strong> 打开注册表Key</p><p>4、如果<strong>IopOpenRegistryKeyIopLoadDriver</strong>成功，则调用 <strong>IopLoadDriver</strong></p><p>5、判断<strong>IopLoadDriver</strong>调用结果</p><p>6、<strong>IopCallDriverReinitializationRoutines();</strong></p><h4 id="IopLoadDriver"><a href="#IopLoadDriver" class="headerlink" title="IopLoadDriver"></a>IopLoadDriver</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">IopLoadDriver</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN  HANDLE      KeyHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN  BOOLEAN     CheckForSafeBoot,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN  BOOLEAN     IsFilter,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT NTSTATUS   *DriverEntryStatus</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>1、根据注册标键拿到驱动程序的全路径名</p><p>2、在<strong>PsLoadedModuleList</strong>里寻找是否驱动已经加载</p><p>3、<strong>MmLoadSystemImage</strong>加载（将驱动程序加载到系统地址空间）</p><p>4、<strong>IopPrepareDriverLoading</strong> （具体操作再分析）  // win10 是<strong>PnpPrepareDriverLoading</strong></p><p>5、通过<strong>ObCreateObject</strong>创建<strong>DriverObject</strong></p><p>6、初始化DriverObject域， （重点DriverObject-&gt;DriverInit = (PDRIVER_INITIALIZE) entryPoint）</p><p>7、插入DriverObject到句柄表</p><p>8、初始化 DriverObject-&gt;DriverName   DriverObject-&gt;DriverExtension-&gt;ServiceKeyName</p><p>9、DriverObject-&gt;DriverInit( DriverObject, &amp;registryPath-&gt;Name ); 调用<strong>DriverEntry</strong></p><p>10、为未设置的MajorFunction设置IRP函数 : <strong>IopInvalidDeviceRequest</strong>;</p><p>11、<strong>IopReadyDeviceObjects</strong> ：将DeviceObject DO_DEVICE_INITIALIZING标志清理掉</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 分析驱动加载中的关键函数(上篇)&lt;/p&gt;</summary>
    
    
    
    <category term="C/C++" scheme="https://flame0920.github.io/flame.github.io/categories/C-C/"/>
    
    <category term="Driver" scheme="https://flame0920.github.io/flame.github.io/categories/C-C/Driver/"/>
    
    <category term="WRK" scheme="https://flame0920.github.io/flame.github.io/categories/C-C/Driver/WRK/"/>
    
    
    <category term="Driver" scheme="https://flame0920.github.io/flame.github.io/tags/Driver/"/>
    
    <category term="C/C++" scheme="https://flame0920.github.io/flame.github.io/tags/C-C/"/>
    
    <category term="WRK" scheme="https://flame0920.github.io/flame.github.io/tags/WRK/"/>
    
  </entry>
  
</feed>
