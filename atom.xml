<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flame&#39;s Security Home</title>
  
  
  <link href="https://flame0920.github.io/flame.github.io/atom.xml" rel="self"/>
  
  <link href="https://flame0920.github.io/flame.github.io/"/>
  <updated>2021-11-16T11:35:09.749Z</updated>
  <id>https://flame0920.github.io/flame.github.io/</id>
  
  <author>
    <name>BurnFlame</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WRK驱动加载流程分析</title>
    <link href="https://flame0920.github.io/flame.github.io/2021/11/16/WRK%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://flame0920.github.io/flame.github.io/2021/11/16/WRK%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</id>
    <published>2021-11-16T10:45:30.000Z</published>
    <updated>2021-11-16T11:35:09.749Z</updated>
    
    <content type="html"><![CDATA[<p> 分析驱动加载中的关键函数</p><span id="more"></span><h3 id="驱动加载中的关键函数"><a href="#驱动加载中的关键函数" class="headerlink" title="驱动加载中的关键函数"></a>驱动加载中的关键函数</h3><ul><li>NtLoadDriver<ul><li>IopLoadUnloadDriver<ul><li>IopLoadDriver<ul><li>MmLoadSystemImage</li><li>IopPrepareDriverLoading</li></ul></li><li>IopCallDriverReinitializationRoutines</li></ul></li></ul></li></ul><h3 id="关键函数分析"><a href="#关键函数分析" class="headerlink" title="关键函数分析"></a>关键函数分析</h3><h4 id="NtLoadDriver"><a href="#NtLoadDriver" class="headerlink" title="NtLoadDriver"></a>NtLoadDriver</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">NtLoadDriver</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PUNICODE_STRING DriverServiceName</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1、判断是否是用户模式调用</span></span><br><span class="line">    <span class="comment">// 2、如果是用户模式调用，则检查DriverServiceName</span></span><br><span class="line">    <span class="comment">// 3、初始化LOAD_PACKET</span></span><br><span class="line">    <span class="comment">// 4、判断是否是系统线程，如果是系统线程则直接调用IopLoadUnloadDriver</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PsGetCurrentProcessByThread</span>(CurrentThread) == PsInitialSystemProcess) &#123;</span><br><span class="line">        <span class="built_in">IopLoadUnloadDriver</span>(&amp;loadPacket);    <span class="comment">// 系统线程，直接调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 5、如果不是系统线程，则是指工作环境，并等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6、返回status</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IopLoadUnloadDriver"><a href="#IopLoadUnloadDriver" class="headerlink" title="IopLoadUnloadDriver"></a>IopLoadUnloadDriver</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">IopLoadUnloadDriver</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PVOID Parameter</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>1、如果存在DriverObject 则调用DriverUnload</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (loadPacket-&gt;DriverObject) &#123;</span><br><span class="line">    </span><br><span class="line">    loadPacket-&gt;DriverObject-&gt;<span class="built_in">DriverUnload</span>( loadPacket-&gt;DriverObject );</span><br><span class="line">    status = STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、loadPacket-&gt;DriverObject == nullptr, 则说明是<strong>加载驱动</strong></p><p>3、<strong>IopOpenRegistryKey</strong> 打开注册表Key</p><p>4、如果<strong>IopOpenRegistryKeyIopLoadDriver</strong>成功，则调用 <strong>IopLoadDriver</strong></p><p>5、判断<strong>IopLoadDriver</strong>调用结果</p><p>6、<strong>IopCallDriverReinitializationRoutines();</strong></p><h4 id="IopLoadDriver"><a href="#IopLoadDriver" class="headerlink" title="IopLoadDriver"></a>IopLoadDriver</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">IopLoadDriver</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN  HANDLE      KeyHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN  BOOLEAN     CheckForSafeBoot,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN  BOOLEAN     IsFilter,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT NTSTATUS   *DriverEntryStatus</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>1、根据注册标键拿到驱动程序的全路径名</p><p>2、在<strong>PsLoadedModuleList</strong>里寻找是否驱动已经加载</p><p>3、<strong>MmLoadSystemImage</strong>加载（将驱动程序加载到系统地址空间）</p><p>4、<strong>IopPrepareDriverLoading</strong> （具体操作再分析）  // win10 是<strong>PnpPrepareDriverLoading</strong></p><p>5、创建DriverObject</p><p>6、初始化DriverObject域， （重点DriverObject-&gt;DriverInit = (PDRIVER_INITIALIZE) entryPoint）</p><p>7、插入DriverObject到句柄表</p><p>8、初始化 DriverObject-&gt;DriverName   DriverObject-&gt;DriverExtension-&gt;ServiceKeyName</p><p>9、DriverObject-&gt;DriverInit( DriverObject, &amp;registryPath-&gt;Name ); 调用<strong>DriverEntry</strong></p><p>10、为未设置的MajorFunction设置IRP函数 : <strong>IopInvalidDeviceRequest</strong>;</p><p>11、<strong>IopReadyDeviceObjects</strong> ：将DeviceObject DO_DEVICE_INITIALIZING标志清理掉</p><h4 id="MmLoadSystemImage"><a href="#MmLoadSystemImage" class="headerlink" title="MmLoadSystemImage"></a>MmLoadSystemImage</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MmLoadSystemImage</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PUNICODE_STRING ImageFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PUNICODE_STRING NamePrefix OPTIONAL,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PUNICODE_STRING LoadedBaseName OPTIONAL,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG LoadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PVOID *ImageHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PVOID *ImageBaseAddress</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 分析驱动加载中的关键函数&lt;/p&gt;</summary>
    
    
    
    <category term="C/C++" scheme="https://flame0920.github.io/flame.github.io/categories/C-C/"/>
    
    <category term="Driver" scheme="https://flame0920.github.io/flame.github.io/categories/C-C/Driver/"/>
    
    
    <category term="Driver" scheme="https://flame0920.github.io/flame.github.io/tags/Driver/"/>
    
    <category term="C/C++" scheme="https://flame0920.github.io/flame.github.io/tags/C-C/"/>
    
  </entry>
  
</feed>
